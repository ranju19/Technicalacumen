cd /opt/techacumen-chat

cat > server.js <<'EOF'
'use strict';

require('dotenv').config();
const express = require('express');
const cors = require('cors');

// ---- Env ----
const PORT = process.env.PORT || 8000;
const ORIGIN = process.env.ALLOWED_ORIGIN || '*';
const REGION = process.env.AWS_REGION || 'us-east-1';

// ---- App ----
const app = express();
app.use(cors({ origin: ORIGIN === '*' ? true : [ORIGIN], credentials: true }));
app.use(express.json({ limit: '1mb' }));

app.get('/health', (_req, res) => res.json({ ok: true, region: REGION }));

// ---- AWS SDK v3: Lex ----
const { LexRuntimeV2Client, RecognizeTextCommand } = require('@aws-sdk/client-lex-runtime-v2');
const lex = new LexRuntimeV2Client({ region: REGION });

app.post('/api/lex/text', async (req, res) => {
  try {
    const { text, sessionId } = req.body || {};
    if (!text) return res.status(400).json({ error: 'text required' });

    const out = await lex.send(new RecognizeTextCommand({
      botId: process.env.LEX_BOT_ID,
      botAliasId: process.env.LEX_BOT_ALIAS_ID,
      localeId: process.env.LEX_LOCALE || 'en_US',
      sessionId: sessionId || ('web-' + Math.random().toString(36).slice(2)),
      text
    }));

    const reply = (out.messages || []).map(m => m.content).filter(Boolean).join('\n') || '(no response)';
    return res.json({ reply, sessionId: out.sessionId });
  } catch (err) {
    console.error('LEX_ERROR', err);
    return res.status(500).json({ error: err.name || 'LexFailed', message: err.message });
  }
});

// ---- AWS SDK v3: Chime Messaging (simple send/list) ----
const { ChimeSDKMessagingClient, SendChannelMessageCommand, ListChannelMessagesCommand } =
  require('@aws-sdk/client-chime-sdk-messaging');
const chimeMsg = new ChimeSDKMessagingClient({ region: REGION });

// Send a message into a channel
app.post('/api/chime/send', async (req, res) => {
  try {
    const ChannelArn = req.body.channelArn || process.env.CHIME_CHANNEL_ARN;
    const ChimeBearer = req.body.senderArn || process.env.CHIME_APP_USER_ARN;
    const Content = req.body.content;

    if (!Content) return res.status(400).json({ error: 'content required' });

    const out = await chimeMsg.send(new SendChannelMessageCommand({
      ChannelArn,
      ChimeBearer,
      Content,
      Persistence: 'PERSISTENT',
      Type: 'STANDARD',
      ClientRequestToken: cryptoRandom()
    }));

    return res.json(out);
  } catch (err) {
    console.error('CHIME_SEND_ERROR', err);
    return res.status(403).json({ error: err.name || 'ChimeSendFailed', message: err.message });
  }
});

// List messages (initial load or polling)
app.get('/api/chime/list', async (req, res) => {
  try {
    const ChannelArn = req.query.channelArn || process.env.CHIME_CHANNEL_ARN;
    const ChimeBearer = req.query.bearer || process.env.CHIME_APP_USER_ARN;
    const NextToken = req.query.nextToken;

    const out = await chimeMsg.send(new ListChannelMessagesCommand({
      ChannelArn,
      ChimeBearer,
      SortOrder: 'ASCENDING',
      MaxResults: 50,
      NextToken
    }));

    return res.json(out);
  } catch (err) {
    console.error('CHIME_LIST_ERROR', err);
    return res.status(403).json({ error: err.name || 'ChimeListFailed', message: err.message });
  }
});

// ---- Helpers ----
function cryptoRandom() {
  try { return require('crypto').randomUUID(); } catch { return Math.random().toString(36).slice(2); }
}

// ---- Start ----
app.listen(PORT, () => {
  console.log(`Server up on :${PORT} (region ${REGION})`);
});
EOF

